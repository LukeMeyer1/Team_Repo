#!/usr/bin/env python3
import argparse, sys, os
from pathlib import Path
import Orchestrator

def validate_environment_variables():
    """Validate required environment variables at startup."""
    # Validate GitHub token
    github_token = os.getenv("GITHUB_TOKEN")
    if not github_token or len(github_token.strip()) == 0:
        # print("Error: GITHUB_TOKEN environment variable is not set or is empty.", file=sys.stderr)
        sys.exit(1)

    # Check if GitHub token is valid by making a simple API call
    try:
        import requests
        response = requests.get(
            "https://api.github.com/user",
            headers={"Authorization": f"token {github_token}"},
            timeout=10
        )
        if response.status_code != 200:
            # print("Error: GITHUB_TOKEN is invalid or expired.", file=sys.stderr)
            sys.exit(1)
    except requests.exceptions.RequestException as e:
        # print(f"Error: Unable to validate GITHUB_TOKEN due to network error: {e}", file=sys.stderr)
        sys.exit(1)

    # Validate log file path
    log_file = os.getenv("LOG_FILE")
    if log_file:
        parent = os.path.dirname(log_file) or "."
        if not os.path.isdir(parent):
            sys.stderr.write(f"ERROR: LOG_FILE parent dir does not exist: {parent}\n")
            sys.exit(1)
        try:
            with open(log_file, "a", encoding="utf-8"):
                pass
        except Exception as e:
            sys.stderr.write(f"ERROR: invalid LOG_FILE={log_file}: {e}\n")
            sys.exit(1)

    # Check if the parent directory exists and is writable
    try:
        # Create parent directories if they don't exist
        log_path.parent.mkdir(parents=True, exist_ok=True)

        # Test if we can write to the log file location
        # Try to touch the file to check write permissions
        log_path.touch(exist_ok=True)

    except (OSError, PermissionError) as e:
        print(f"Error: Cannot write to log file path '{log_file}': {e}", file=sys.stderr)
        sys.exit(1)

def main(argv=None) -> int:
    # Validate environment variables at startup
    validate_environment_variables()

    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(description="CLI for Trustworthy Model Re-use")
    parser.add_argument("command", help="install | test | URL_FILE")

    # Parse-known so we can forward extras ONLY for 'test'
    args, extra = parser.parse_known_args(argv)

    if args.command == "test":
        # Forward any remaining args (e.g., --cov, -k ...) to pytest
        return Orchestrator.run_tests(pytest_args=extra)

    # For every other command, unknown args are an error (strict mode)
    if extra:
        parser.error(f"unrecognized arguments: {' '.join(extra)}")  # exit code 2

    if args.command == "install":
        return Orchestrator.install_dependencies()

    # Treat anything else as a file-first workflow
    file_path = Path(args.command)
    if not file_path.exists():
        print(f"Error: file {file_path} not found.", file=sys.stderr)
        return 1
    return Orchestrator.process_urls(file_path)

if __name__ == "__main__":
    raise SystemExit(main())