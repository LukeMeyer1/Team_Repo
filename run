#!/usr/bin/env python3
# from Logger import validate_log_file_or_die #new import
# validate_log_file_or_die()

import argparse, sys, os

def _early_log_file_check():
    raw = os.getenv("LOG_FILE") or os.getenv("LOG_PATH") or os.getenv("LOGFILE")
    if raw is None:
        return  # not set -> do nothing

    p = raw.strip()
    if not p:
        sys.stderr.write("ERROR: LOG_FILE is empty or whitespace.\n"); sys.exit(1)

    p = os.path.expanduser(os.path.expandvars(p))

    # reject directories / trailing slash
    if p.endswith(os.sep) or (os.altsep and p.endswith(os.altsep)) or os.path.isdir(p):
        sys.stderr.write(f"ERROR: LOG_FILE points to a directory: {raw}\n"); sys.exit(1)

    parent = os.path.dirname(p) or "."
    if not os.path.isdir(parent):
        sys.stderr.write(f"ERROR: LOG_FILE parent dir does not exist: {parent}\n"); sys.exit(1)

    # must ALREADY exist (do not create)
    if not os.path.isfile(p):
        sys.stderr.write(f"ERROR: LOG_FILE does not exist: {p}\n"); sys.exit(1)

    # must be writable without creating/truncating
    try:
        with open(p, "r+", encoding="utf-8"):
            pass
    except Exception as e:
        sys.stderr.write(f"ERROR: LOG_FILE not writable: {p}: {e}\n"); sys.exit(1)

_early_log_file_check()
# --- END EARLY CHECK ---


from pathlib import Path
import Orchestrator


def validate_environment_variables():
    """Validate required environment variables at startup."""
    # Validate GitHub token only if it's set
    github_token = os.getenv("GITHUB_TOKEN")
    if github_token and len(github_token.strip()) > 0:
        # Check if GitHub token is valid by making a simple API call
        try:
            import requests
            response = requests.get(
                "https://api.github.com/user",
                headers={"Authorization": f"token {github_token}"},
                timeout=10
            )
            if response.status_code != 200:
                sys.exit(1)
        except requests.exceptions.RequestException as e:
            sys.exit(1)
        except ImportError:
            # If requests is not available, skip validation but warn
            pass

    # Validate log file path only if LOG_FILE is explicitly set
    log_file = os.getenv("LOG_FILE")
    if log_file:
        try:
            log_path = Path(log_file)
            # Check if parent directory exists and is writable
            if not log_path.parent.exists():
                sys.exit(1)
            if not os.access(log_path.parent, os.W_OK):
                sys.exit(1)
        except (OSError, PermissionError) as e:
            sys.exit(1)

def main(argv=None) -> int:
    # Validate environment variables at startup
    validate_environment_variables()
    

    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(description="CLI for Trustworthy Model Re-use")
    parser.add_argument("command", help="install | test | URL_FILE")

    # Parse-known so we can forward extras ONLY for 'test'
    args, extra = parser.parse_known_args(argv)

    if args.command == "test":
        # Forward any remaining args (e.g., --cov, -k ...) to pytest
        return Orchestrator.run_tests(pytest_args=extra)

    # For every other command, unknown args are an error (strict mode)
    if extra:
        parser.error(f"unrecognized arguments: {' '.join(extra)}")  # exit code 2

    if args.command == "install":
        return Orchestrator.install_dependencies()

    # Treat anything else as a file-first workflow
    file_path = Path(args.command)
    if not file_path.exists():
        print(f"Error: file {file_path} not found.", file=sys.stderr)
        return 1
    return Orchestrator.process_urls(file_path)

if __name__ == "__main__":
    raise SystemExit(main())